def beautifulBinaryString(binaryString):
    ASCII_A = 65
    listA = []
    listB = []
    charIdxs = [list(listA), list(listB)]
    for i in range(len(binaryString)):
        if (binaryString[i] != 'A' and binaryString[i] != 'B'):
            return False
        charIdxs[ord(binaryString[i]) - ASCII_A].append(i)
    print(charIdxs)
    if (len(charIdxs[0]) % 2 or len(charIdxs[1]) % 2):
        return False
    for charIdx in charIdxs:
        matchIdx = []
        for i in range(len(charIdx) - 1):
            if i in matchIdx:
                continue
            for j in range(i + 1, len(charIdx)):
                if j in matchIdx:
                    continue
                if (j  - i) % 2 == 0:   #insect same
                    continue
                else:
                    if (charIdx[j] - charIdx[i] % 2 != 0): #not insect diff
                        matchIdx.append(i)
                        matchIdx.append(j)
                        break
        print(matchIdx)                        
        
                        
    return True
    
    
print(beautifulBinaryString("BABBBA"))



import openpyxl

D_HEADER_NAME   = 0
D_PARENT_NAME   = 1
D_CELL_INFO     = 2
D_SEPERATOR     = ":"

#   CellInfo: [cell : openpyxl.Cell, rowSize: int, columnSize: int]
#   HeaderInfo: [headerCellInfo : CellInfo, parentInfo : HeaderInfo]
#

class CellInfo:
    def __init__(self, cell, rowSize, columnSize):
        self.mCell = cell
        self.mRowSize = rowSize
        self.mColumnSize = columnSize

    def __eq__(self, other): 
        if not isinstance(other, CellInfo):
            # don't attempt to compare against unrelated types
            return NotImplemented
        return "CellInfo " + self.mCell == other.mCell and self.mRowSize == other.mRowSize and self.mColumnSize == other.mColumnSize

    def __str__(self):        
        return self.mCell.__str__() + "::" + str(self.mRowSize) + "::" + str(self.mColumnSize)
#===========================================================================================================================
class HeaderInfo:
    def __init__(self, cellInfo, parentHeaderInfo):
        self.mHeaderCellInfo = cellInfo
        self.mParenHeaderInfo = parentHeaderInfo
        self.mFullName = self.GetFullHeaderName()

    def __eq__(self, other): 
        if not isinstance(other, HeaderInfo):
            # don't attempt to compare against unrelated types
            return NotImplemented
        return self.mHeaderCellInfo == other.mHeaderCellInfo and \
                self.mParenHeaderInfo == other.mParenHeaderInfo and \
                self.mFullName == other.mFullName

    def __str__(self):        
        # + self.mParenHeaderInfo.__str__() + "::"
        return "HeaderInfo " + self.mHeaderCellInfo.__str__()  + "::"  + self.mFullName 

    def GetFullHeaderName(self):
        headerName = self.mHeaderCellInfo.mCell.value
        parentName = ""
        parentInfo = self.mParenHeaderInfo
        while (parentInfo != None):
            parentName = parentName + D_SEPERATOR + parentInfo.mHeaderCellInfo.mCell.value
            parentInfo = parentInfo.mParenHeaderInfo
        return headerName + parentName + D_SEPERATOR
#===========================================================================================================================

import openpyxl

D_HEADER_NAME   = 0
D_PARENT_NAME   = 1
D_CELL_INFO     = 2
D_SEPERATOR     = ":"

#   CellInfo: [cell : openpyxl.Cell, rowSize: int, columnSize: int]
#   HeaderInfo: [headerCellInfo : CellInfo, parentInfo : HeaderInfo]
#

class CellInfo:
    def __init__(self, cell, rowSize, columnSize):
        self.mCell = cell
        self.mRowSize = rowSize
        self.mColumnSize = columnSize

    def __eq__(self, other): 
        if not isinstance(other, CellInfo):
            # don't attempt to compare against unrelated types
            return NotImplemented
        return "CellInfo " + self.mCell == other.mCell and self.mRowSize == other.mRowSize and self.mColumnSize == other.mColumnSize

    def __str__(self):        
        return self.mCell.__str__() + "::" + str(self.mRowSize) + "::" + str(self.mColumnSize)
#===========================================================================================================================
class HeaderInfo:
    def __init__(self, cellInfo, parentHeaderInfo):
        self.mHeaderCellInfo = cellInfo
        self.mParenHeaderInfo = parentHeaderInfo
        self.mFullName = self.GetFullHeaderName()

    def __eq__(self, other): 
        if not isinstance(other, HeaderInfo):
            # don't attempt to compare against unrelated types
            return NotImplemented
        return self.mHeaderCellInfo == other.mHeaderCellInfo and \
                self.mParenHeaderInfo == other.mParenHeaderInfo and \
                self.mFullName == other.mFullName

    def __str__(self):        
        # + self.mParenHeaderInfo.__str__() + "::"
        return "HeaderInfo " + self.mHeaderCellInfo.__str__()  + "::"  + self.mFullName 

    def GetFullHeaderName(self):
        headerName = self.mHeaderCellInfo.mCell.value
        parentName = ""
        parentInfo = self.mParenHeaderInfo
        while (parentInfo != None):
            parentName = parentName + D_SEPERATOR + parentInfo.mHeaderCellInfo.mCell.value
            parentInfo = parentInfo.mParenHeaderInfo
        return headerName + parentName + D_SEPERATOR
#===========================================================================================================================

class ExcelFile:
    def __init__(self, path):
        self.mDefaultSheetName = "Sheet1"
        self.mPath = path
        self.mHeaderArea = ""
        self.mWorkBook = None
        self.mSheet = None
        self.mHeaderList = []       
        self.mHeaderCellInfo = []           # list of info of main cell of header
        self.mColumCount = 0 # number of column header
        self.mRowCount  = 0 # number of data row
        self.mDictData = {}        
 

    def __GetValueWithMergedLookup(self, cell):
        # Get each range merged cell in sheet.
        # colCor = cell.coordinate[0]
        # rowCor = cell.coordinate[1]
        cellCoor =  openpyxl.utils.cell.coordinate_from_string(cell.coordinate)
        ret = None
        for cellRange in self.mSheet.merged_cells.ranges:
            # print("cellRange=", cellRange)
            # Check if input cell is in cell range
            topLeftCoor = openpyxl.utils.cell.coordinate_from_string(cellRange.__str__().split(":")[0])                   
            botRightCoor = openpyxl.utils.cell.coordinate_from_string(cellRange.__str__().split(":")[1])
            # print(topLeftCoor, botRightCoor)
            if (cellCoor[0] <= botRightCoor[0] and cellCoor[0] >= topLeftCoor[0] \
                and cellCoor[1] <= botRightCoor[1] and cellCoor[1] >= topLeftCoor[1]):
                # Get top left cell
                mainCell = self.mSheet[cellRange.__str__().split(":")[0]]
                # print(mainCell)
                ret = mainCell.value
                break
        if (ret == None):
            ret = cell.value
        # print(ret)
        return ret

    # Get parent header infor this cell belongs to (this cell is in parent header)
    # return HeaderInfo or None
    def __GetParentHeaderInfo(self, headerInfoList: list, cell):
        for headerCellInfo in headerInfoList:
            mergedCells = self.__GetMergedCells(headerCellInfo.mHeaderCellInfo)
            if cell in mergedCells:
                return headerCellInfo
        return None     

    # Get all merged cells are in a CellInfo object
    # return list of Cells    
    def __GetMergedCells(self, cellInfo: CellInfo):
        mergedCells = []
        anchorRow = cellInfo.mCell.row
        anchorCol = cellInfo.mCell.column
        for row in range(cellInfo.mRowSize):
            for col in range(cellInfo.mColumnSize):
                mergedCells.append(self.mSheet.cell(row=anchorRow+row, column=anchorCol+col))
        # print(mergedCells)                
        return mergedCells                

    # Get list of main cell info in header.
    # return list of CellInfo (s)
    def __GetHeaderCellInfo(self):
        headerCellInfos = []
        # get list of merged cell
        mergedCellList = []
        # Get each range merged cell in sheet.
        for cellRange in self.mSheet.merged_cells.ranges:
            # row size of header
            rowNum = len(self.mSheet[cellRange.__str__()])
            # column size of header
            colNum = len(self.mSheet[cellRange.__str__()][0])
            cell = self.mSheet[cellRange.__str__()][0][0]
            mergedCellList.append(CellInfo(cell, rowNum, colNum))

        # For each row in header sheet    
        for rowOfCell in self.mSheet[self.mHeaderArea]:
            for cell in rowOfCell:
                if cell.value != None:      # this cell has value
                    # print(cell.coordinate, cell.value)
                    # default cell infor in header area.
                    cellInfo = CellInfo(cell, 1, 1)                    
                    for ecellInfo in mergedCellList:
                        # if this is the merged cell.
                        if (cell == ecellInfo.mCell):
                            cellInfo = ecellInfo
                            break
                    headerCellInfos.append(cellInfo)
        return headerCellInfos                    


    # Get list of header info
    def __GetHeaderList(self):
        self.mHeaderCellInfo = self.__GetHeaderCellInfo()
        headerInfoList = []
        # iterator each cell to determine struct
        for cellInfo in self.mHeaderCellInfo:
            cellObj = cellInfo.mCell
            parentHeaderInfo = None
            if (cellObj.row > 1):
                # if upper cell has a value. It is parent of this cell
                upperCell = self.mSheet.cell(row=cellObj.row - 1, column=cellObj.column)
                parentHeaderInfo = self.__GetParentHeaderInfo(headerInfoList, upperCell)
            headerInfo = HeaderInfo(cellInfo, parentHeaderInfo)
            headerInfoList.append(headerInfo)
        return headerInfoList               

    # Check if a name is a header full name. Ex: Function is a name of header full name Function:PIC:Company
    def __CheckMatchHeader(self, inputStr:str, headerFullName:str):
        if (inputStr == headerFullName):
            return True
        inputStruct = inputStr.split(D_SEPERATOR, 1)
        checkStruct = headerFullName.split(D_SEPERATOR, 1)
        if (inputStruct[0] == checkStruct[0]):
            if len(inputStruct) > 1 and len(checkStruct) > 1:
                if inputStruct[1] and inputStruct[1] in checkStruct[1]:
                    return True
                else:
                    return False                    
            else:
                return True
        return False  

    # Get list of matched header with a input name
    # headerStruct: "End Date:Test term"
    # return list of CellInfo (s)
    def __GetMatchHeader(self, headerStruct: str):
        matchHeader = []
        for headerInfo in self.mHeaderList:
            if (self.__CheckMatchHeader(headerStruct, headerInfo.mFullName)):
                matchHeader.append(headerInfo.mHeaderCellInfo)
        return matchHeader     

    # Get the name of most header name. Ex "Function:PIC:Company"
    # return str
    def __GetMostChildHeaderName(self, column: int):
        for i in range(len(self.mHeaderList), 0, -1):
            headerInfo = self.mHeaderList[i-1]
            if (headerInfo.mHeaderCellInfo.mCell.column == column):    
                return headerInfo.mFullName
        return ""                

    # Load all data and store to mDictData                                
    def __LoadData(self):
        self.mRowCount = 0
        rowValue = {}
        rowOffset = 1
        rowValue = self.Read(rowOffset)
        stop = all(value==None for value in rowValue.values())
        # init key for data
        for key in rowValue:
            self.mDictData[key] = []
        while (not stop):
            # load each field of row value to mDictData
            # print(rowValue)
            for key in rowValue:
                self.mDictData[key].append(rowValue[key])
            self.mRowCount += 1
            rowOffset += 1
            rowValue = self.Read(rowOffset)
            stop = all(value==None for value in rowValue.values())
        # print("self.mRowCount=", self.mRowCount)            

    # Open file
    def Open(self, sheetName, headerArea):
        self.mHeaderArea = headerArea
        self.mWorkBook = openpyxl.load_workbook(self.mPath)
        self.mDefaultSheetName = sheetName
        self.mSheet = self.mWorkBook[self.mDefaultSheetName]
        self.mColumCount = len(self.mSheet[self.mHeaderArea][0])
        self.mHeaderList = self.__GetHeaderList()   
        self.__LoadData()     

    # Close file                
    def Close(self):
        self.mWorkBook.save(self.mPath)
                 
    # Get a cell at header name and row offset. Row offset start at 1
    # Ex: GetCellAt("Function:PIC:Company", 1):
    # return Cell                 
    def GetCellAt(self, headerStruct: str, rowOffset: int):
        matchHeader = self.__GetMatchHeader(headerStruct)
        if (len(matchHeader) == 0):
                raise Exception("Cannot find header: " +  headerStruct)
        if (len(matchHeader) > 1):
            raise Exception("More than one header: " + headerStruct)
        # print(matchHeader)
        col = matchHeader[0].mCell.column
        row = (matchHeader[0].mCell.row + matchHeader[0].mRowSize - 1) + rowOffset
        # print(row, col)
        return self.mSheet.cell(row=row, column=col)

    # Write to cell at header name and row offset.
    def Write(self, headerStruct: str, rowOffset: int, value: str):
        cell = self.GetCellAt(headerStruct, rowOffset)
        cell.value = value                     

    # Read data of a row offset
    # return Dictionary. Ex {"Name": "Person1", 
    #                       "Function": "API"}
    def Read(self, rowOffset: int):
        returnValue = {}
        mostChildRow = int(self.mHeaderArea.split(":")[1][-1])
        for i in range(self.mColumCount):
            headerName = self.__GetMostChildHeaderName(column=i+1)
            # print(headerName)
            # returnValue[headerName] = self.mSheet.cell(row=mostChildRow+rowOffset,column=i+1).value  
            cell = self.mSheet.cell(row=mostChildRow+rowOffset,column=i+1)
            returnValue[headerName] = self.__GetValueWithMergedLookup(cell)          
        return returnValue

    def ReadAtField(self, headerName: str):
        returnValue = []
        matchHeader = self.__GetMatchHeader(headerName)
        if (len(matchHeader) == 0):
                raise Exception("Cannot find header: " + headerName)
        if (len(matchHeader) > 1):
            raise Exception("More than one header: " + headerName)
        # print(matchHeader)
        col = matchHeader[0].mCell.column
        for i in range(1, self.mRowCount + 1):
            row = (matchHeader[0].mCell.row + matchHeader[0].mRowSize - 1) + i
            cell = self.mSheet.cell(row=row, column=col)
            value =  self.__GetValueWithMergedLookup(cell)
            returnValue.append(value)
        return returnValue

    def GetColumnAtField(self, headerName: str):
        matchHeader = self.__GetMatchHeader(headerName)
        if (len(matchHeader) == 0):
                raise Exception("Cannot find header: " + headerName)
        if (len(matchHeader) > 1):
            raise Exception("More than one header: " + headerName)
        # print(matchHeader)
        return matchHeader[0].mCell.column

    # Read all data 
    # return Dictionary. Ex {"Name": ["Person1", "Person2", "Person3"],
    #                       "Function": ["API1", "API2", "API3"]}
    def ReadAll(self):
        rowValue = {}
        rowOffset = 1
        rowValue = self.Read(rowOffset)
        retValue = {}
        # stop = all(value==None for value in rowValue.values())
        # init key for data
        for key in rowValue:
            key = key[:-1]  # fix bug header name has last :
            retValue[key] = []
                    
        for row in range(1, self.mRowCount+1):
            rowValue = self.Read(row)
            for key in rowValue:
                keyret = key[:-1]  # fix bug header name has last :
                retValue[keyret].append(rowValue[key])  
        return retValue            

    # Read data at conditions
    # outputFields: ["C0:Coverage", "C1:Coverage"]
    # conditionFields: {"File Name": "Test.cpp1", "Function Name": "TestFunction"}
    # return {"C0:Coverage" : ["100%"], "C1:Coverage" : ["100%"]} 
    def ReadCond(self, outputFields: list, conditionFields):
        if (not self.mDictData):
            self.__LoadData()
        # check if output fields is unique
        matchOutputKeys = {}
        returnVal = {}
        outputPairKey = []
        # conditionPairKey = []
        for outputField in outputFields:   # outputField is header name
            tmpKeys = []
            for key in self.mDictData: # key is header full name
                if (self.__CheckMatchHeader(outputField, key)):
                    tmpKeys.append(key)
            if (len(tmpKeys) > 1):
                raise Exception("More than one output field: " + outputField)
            if (len(tmpKeys) == 0):
                raise Exception("Cannot find output field: " + outputField)                
            matchOutputKeys[tmpKeys[0]] = [] 
            returnVal[outputField] = []
            outputPairKey.append((tmpKeys[0], outputField))
        # print("matchOutputKeys=", matchOutputKeys)              
        # print("returnVal=", returnVal)       
        # print("outputPairKey=", outputPairKey)
        # check if condition field is unique
        matchConditionKeys = {}
        conditionFields.keys
        for conditionField in conditionFields: # conditionField is header name
            tmpKeys = []
            for key in self.mDictData: # key is header full name
                if (self.__CheckMatchHeader(conditionField, key)):
                    tmpKeys.append(key)
            if (len(tmpKeys) > 1):
                raise Exception("More than one condition field: " + conditionField)
            if (len(tmpKeys) == 0):
                raise Exception("Cannot find output condition: " + conditionField)                
            # conditionPairKey.append((tmpKeys[0], conditionField))   
            matchConditionKeys[tmpKeys[0]] = conditionFields[conditionField]        
        # print("matchConditionKeys=", matchConditionKeys)                                                                                            
        # get index of condition field if equal value
        indexs = []
        for key in matchConditionKeys:
            for i, val in enumerate(self.mDictData[key]):
                if (val == matchConditionKeys[key]):
                   indexs.append(i)
        # print(indexs)                
        # get index has more one time
        numOfcond = len(matchConditionKeys)
        matchIdex = set([x for x in indexs if indexs.count(x) == numOfcond])                            
        # print(matchIdex)
        for key in matchOutputKeys:
            for i in matchIdex:
                matchOutputKeys[key].append(self.mDictData[key][i])
        # print(matchOutputKeys) 
        for pair in outputPairKey:
            returnVal[pair[1]] = matchOutputKeys[pair[0]]      

        # print(returnVal)                 
        return returnVal
