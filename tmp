def beautifulBinaryString(binaryString):
    ASCII_A = 65
    listA = []
    listB = []
    charIdxs = [list(listA), list(listB)]
    for i in range(len(binaryString)):
        if (binaryString[i] != 'A' and binaryString[i] != 'B'):
            return False
        charIdxs[ord(binaryString[i]) - ASCII_A].append(i)
    print(charIdxs)
    if (len(charIdxs[0]) % 2 or len(charIdxs[1]) % 2):
        return False
    for charIdx in charIdxs:
        matchIdx = []
        for i in range(len(charIdx) - 1):
            if i in matchIdx:
                continue
            for j in range(i + 1, len(charIdx)):
                if j in matchIdx:
                    continue
                if (j  - i) % 2 == 0:   #insect same
                    continue
                else:
                    if (charIdx[j] - charIdx[i] % 2 != 0): #not insect diff
                        matchIdx.append(i)
                        matchIdx.append(j)
                        break
        print(matchIdx)                        
        
                        
    return True
    
    
print(beautifulBinaryString("BABBBA"))



import openpyxl

class OutputFile:
    def __init__(self, path, headerArea):
        self.mDefaultSheetName = "Sheet1"
        self.mPath = path
        self.mHeaderArea = headerArea
        self.mWorkBook = None
        self.mSheet = None
        self.mHeaderList = []

    def GetValueWithMergeLookup(self, cell):
        idx = cell.coordinate
        for cellRange in self.mSheet.merged_cells.ranges:
            merged_cells = list(openpyxl.utils.rows_from_range(cellRange.__str__()))
            for ecell in merged_cells:
                # print(ecell)
                if idx in ecell:
                    # If this is a merged cell, return  the first cell of the merge range
                    return self.mSheet[ecell[0]].value
        return self.mSheet[idx].value       

    def IsHeaderCell(self, cell):
        idx = cell.coordinate
        for cellRange in self.mSheet.merged_cells.ranges:
            # get list of cells in range.
            merged_cells = list(openpyxl.utils.rows_from_range(cellRange.__str__()))
            for ecell in merged_cells:
                # if this cell is in range, and this cell is the first cell.
                if idx in ecell:
                    return ecell[0] == idx
        # if this cell is not merged cell, check it value.                
        return cell.value != None    

    def GetHeaderList(self):
        headerList = []
        # iterator each cell to determine struct
        for rowOfCellObjs in self.mSheet[self.mHeaderArea]:
            for cellObj in rowOfCellObjs:
                if self.IsHeaderCell(cellObj):
                    # print(cellObj.coordinate)
                    # if upper cell has a value. It is parent of this cell
                    if (cellObj.row > 1):
                        upperCell = self.mSheet.cell(row=cellObj.row - 1, column=cellObj.column)
                        upperValue = self.GetValueWithMergeLookup(upperCell) 
                        parentHeader = upperValue
                        header = cellObj.value
                        coordinate = cellObj.coordinate
                        headerStruct = [header, parentHeader, coordinate, cellObj]
                        headerList.append(headerStruct)
        return headerList                        

    def Open(self):
        self.mWorkBook = openpyxl.load_workbook(self.mPath)
        self.mSheet = self.mWorkBook[self.mDefaultSheetName]
        self.mHeaderList = self.GetHeaderList()
                
    def Close(self):
        self.mWorkBook.save(self.mPath)

    def Write(self, headerStruct: list, rowOffset: int, value: str):
        headerName = headerStruct[0]
        parentName = None if len(headerStruct) < 2 else headerStruct[1]
        matchHeader = []
        for header in self.mHeaderList:
            if (header[0] == headerName):
                if (parentName == None or not parentName or header[1] == parentName):
                    matchHeader.append(header[2])
        if (len(matchHeader) == 0):
            print("Cannot find header: ", headerName)
            return
        if (len(matchHeader) > 1):
            print("More than one header: ", headerName)
            return
        # print(matchHeader)
        col = self.mSheet[matchHeader[0]].column
        row = self.mSheet[matchHeader[0]].row + rowOffset
        self.mSheet.cell(row=row, column=col).value = value    

    def Read(self, rowOffset: int):
        returnValue = {}
        mostChildRow = int(self.mHeaderArea.split(":")[1][-1])
        for header in self.mHeaderList:
            # get the most child header
            if header[3].row == mostChildRow:
                row = header[3].row +rowOffset
                returnValue[header[0]] = self.mSheet.cell(row=row,column=header[3].column).value

        return returnValue


# Example
outputFile = OutputFile("D:/Workspace/SuportTool/testTargetList_template.xlsx", "A1:J2")        
outputFile.Open()
for i in range(1, 9):
    outputFile.Write(headerStruct=["Start Date", "Test Duration"],  rowOffset=i, value="10/10") 
    outputFile.Write(headerStruct=["End Date", "Test Duration"],    rowOffset=i, value="11/10")
    outputFile.Write(headerStruct=["Start Date", "Fix Duration"],   rowOffset=i, value="10/11") 
    outputFile.Write(headerStruct=["End Date", "Fix Duration"],     rowOffset=i, value="11/11")           
    outputFile.Write(headerStruct=["File Name", ""],                rowOffset=i, value="Test.cpp") 
    outputFile.Write(headerStruct=["Function Name", ""],            rowOffset=i, value="TestFunction")
    outputFile.Write(headerStruct=["C0"],                           rowOffset=i, value="100%")
    outputFile.Write(headerStruct=["C1"],                           rowOffset=i, value="100%")
    outputFile.Write(headerStruct=["Result"],                       rowOffset=i, value="OK")  

val = outputFile.Read(rowOffset=1)
print(val)

outputFile.Close()



